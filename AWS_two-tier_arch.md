# AWS 2-Tier Architecture

A 2-tier architecture is a software architecture that consists of 2 layers, the client tier and the database tier.

## Why create a 2-tier architecture?
A 2-tier architecture provides additional to the DBMS (Database Management System) as it isn't exposed directly to the end user.

## Why should we refactor a monolithic architecture into a 2-tier architecture

One of the biggest disadvantages to a monolithic architecture is that everything is bunched into a single component, and thus a single point of failure. We need to refactor into a 2-tier architecture because monolithic systems lack the agility and flexibility that modern businesses require. Also monolithic architectures are not easily scalable.

![](twotier_diagram.png)

# Task: Create a 2-tier architecture with app and DB layers

Requirements:
- App tier deployed - available on public ip on port 3000
- Create a second tier with required dependencies
  - Ubuntu 18.04
  - Mongodb installed
  - Change mongod.conf 0.0.0.0
  - Security group for our DB, port 27017
     - initially allow from anywhere
     - allow only from app instance
- Create environment variable in app instancce with DB endpoint
- Relaunch the app

To start we created a new instance for our DB that we named `tech201-iwan-db-sg` with the same AMI as we did with our app instance (ubuntu 18.04) and set security groups, first ssh as we did with app and a custom group for our DB port which is 27017.

After we set everything we needed we launched our new instance and we connected to it in the same way as we did with our app instance, through .ssh with our key (which was the same key for app).

Once we are in our instance we run the following commands:
```
sudo apt-get update -y
sudo apt-get upgrade -y
```

What we did next was migrate our provision file for DB (which we had already from the virtualisation class). There are a couple of ways to do this, we can migrate via scp as we did with our app directory, or we can clone the repository containing our provision file. Note cloning a GitHub repo is not considered best practice because if GitHub is down you will run into problems.

Once you have migrated your provision file to the instance, we can then run our provision file. First, we ensure that it has the correct permissions. We will run
```
chmod 700 db_provision.sh
```
Following which we will run the provison file, in this case we run:
```
sudo ./db_provision.sh
```
And to verify that this worked we run
```
sudo systemctl status mongod
```
If everything has been done correctly our output should be 

![](mongod_status.png)

After this, we edit the mongodb file configuration. From the home directory (run `cd ~` if unsure) we run
```
sudo nano /etc/mongod.config
```
In the configuration file we need to navigate to this part
```
# network interfaces
net:
  port: 27017
  bindIp: 127.0.0.1
```
The we need to change the bindIp to `0.0.0.0` to allow our app to connect to the database.

Now that everything is set on our DB instance we can now ssh into our app instance and set our environment variable.

The format for this would be
```
export DB_HOST=mongodb://<ip>:27017/posts
```
For the time being we are using our public IP that is generated by AWS when we connect to this instance. In this runthrough our public IP was `34.242.13.160` and note you should enter the IP for your DB instance in the env var,  not the app.
Note we can verify this is set via 
```
printenv DB_HOST
```
Which will return the value of our env var.

Once we have done this we can install our app, and seed the contents of our database. We do this via the following commands
```
npm install
node seeds/seed.js
```
If everything has worked properly we can start up our app, and if thats running as it should we can check with our IP address.

![](app_on_aws.png)

As we can see here the app is working on the IP address that AWS generated for our instance. Note our setup involved connecting our DB instance which includes the contents of MongoDB, so we verify whether this worked aswell.
 ![](posts_on_aws.png)

 There we go! We have been able to replicate what we did on our vagrant VMs on our AWS EC2 instances!

 # Creating AMI's for our EC2 Instances

 Having instances on AWS costs money, even if they are shut down, so we could terminate them but that would mean losing everything we've set in our instance, thus having to go through the entire setup all over again. What AWS gives us is the option to create an Amazon Machine Image (AMI) for our EC2 instances. 

 ![](architecture_ami_instance.png)

 An AMI is basically a working copy of an instance that holds all the information required to launch that instance. So suppose you shut down an instance and don't restart it for a significant period of time, that will still cost money despite the instance being shut down. It is more cost effective to create a copy of that instance that can be used to relaunch the EC2 Instance later down the line should you or someone want to use it.

 In our example we first did this with our app instance. As we can see earlier, our app instance works. If we are happy with how our instance is running we can create an AMI for our specific instance.

 To satrt this we go to our instance page in  the AWS console (remember that our region should always be set to Ireland) and click on the "Actions" dropdown and then select "Images and templates" then "Create image".

 Here we simply set our ami name and description, we will do this following our previous naming convention i.e. we will name our ami - iwan-tech201-app-ami. We note in our descriptions what we want out security rules to be, what ports we want to allow etc.

 Once we have set everything we can then create our ami. Note it can take some time to create the ami so don't terminate the instance its based off until its status has changed from "pending" to "available". When we are ready, we terminate our instance.

 Once our instance is terminated we can look to relaunch it via the ami we created. We do this by finding the particular ami we want to use, select it, and then select "Launch instance from AMI".
 What happens then is we go into our launch ami page as before only this time we do not need to specify an ami as we did previously since we already have one available. Following this we set our security group rules to be the same as our original instance, so our rules for app should include ssh, https and a custom port for our app with port range 3000.

 Once all that is set, we can launch our app ami instance. The instance should work exactly as the original.

 We can then do the same for our db instance and create an AMI that will run the same way and connect to the app ami instance the same way the original instances used to connect.


 # Cloudwatch and Monitoring
 Generally speaking, when our applications are running and something goes wrong, the first group that will find out is the end user. So we need a way to be able to spot anything out of place before it has an effect on the end user. Amazon has a tool called CloudWatch.

 ![](cloudwatch.png)

 What CloudWatch does is monitor our program, but what we can do is have it moniter certain metrics and alert us if anything is out of place. So we set the metrics to be monitored and if anything breaches the threshold that we set, then the CloudWatch alarm will alert us via SNS email notification so that we are aware that something is goung wring with our program.

 